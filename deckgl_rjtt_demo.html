
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RJTT RWY16R SID TAURA – deck.gl + MapLibre demo</title>
  <style>
    html, body, #map { margin: 0; padding: 0; height: 100%; width: 100%; }
    .legend {
      position: absolute; z-index: 2; top: 12px; left: 12px;
      background: rgba(255,255,255,0.9); padding: 10px 12px; border-radius: 8px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      line-height: 1.4;
    }
    .legend code { background: #f3f3f3; padding: 2px 4px; border-radius: 4px; }
  </style>
  <!-- MapLibre & deck.gl UMD bundles from CDN -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/deck.gl@8.9.36/dist.min.js"></script>
</head>
<body>
  <div id="map"></div>
  <div class="legend">
    <div><strong>RJTT RWY16R &rarr; TT6R1 &rarr; TAURA &rarr; HYE</strong></div>
    <div>高度（Z）はメートル。属性に <code>altitude_ft</code>/<code>altitude_m</code> と制限文言あり。</div>
    <div>注意：研究・可視化デモ用。運航用途不可。</div>
    <div style="margin-top: 12px;">
      <label for="alt-scale" style="display:block; font-weight:600;">高度倍率（0.5x – 30x）</label>
      <input id="alt-scale" type="range" min="-1" max="4.9068905956" step="0.01" value="0"
        style="width: 220px;" />
      <div>現在: <span id="alt-scale-value">1.0x</span></div>
      <div style="font-size: 0.85em; color: #555;">※スライダーは 2<sup>x</sup> 対数スケールです。</div>
    </div>
  </div>
  <script>
    // Minimal raster OSM style (no token required)
    const OSM_STYLE = {
      "version": 8,
      "sources": {
        "osm": {
          "type": "raster",
          "tiles": ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          "tileSize": 256,
          "attribution": "&copy; OpenStreetMap contributors"
        }
      },
      "layers": [
        { "id": "osm", "type": "raster", "source": "osm" }
      ]
    };

    // Initial camera around Tokyo Bay / Haneda
    const INITIAL = { center: [139.80, 35.55], zoom: 9, pitch: 60, bearing: 20 };

    // Create MapLibre map
    const map = new maplibregl.Map({
      container: 'map',
      style: OSM_STYLE,
      center: INITIAL.center,
      zoom: INITIAL.zoom,
      pitch: INITIAL.pitch,
      bearing: INITIAL.bearing,
      antialias: true,
      pitchWithRotate: true,  // 右ドラッグでのピッチ操作を許可
      dragRotate: true,       // 回転操作を有効
      minPitch: 0,
      maxPitch: 80          // 地表スレスレまで許可（90は不可）
    });
    map.addControl(new maplibregl.NavigationControl(), 'top-right');

    // Deck.gl overlay
    const overlay = new deck.MapboxOverlay({
      interleaved: true,
      layers: []
    });
    map.addControl(overlay);

    const WIDTH_M = 20;
    const HEIGHT_M = 4;
    const RAD2DEG = 180 / Math.PI;
    const TILE_SIZE = 512;

    function makeUnitBoxMesh() {
      const positions = new Float32Array([
        // +Y face
        -0.5, 0.5, -0.5,
        0.5, 0.5, -0.5,
        0.5, 0.5, 0.5,
        -0.5, 0.5, 0.5,
        // -Y face
        -0.5, -0.5, -0.5,
        -0.5, -0.5, 0.5,
        0.5, -0.5, 0.5,
        0.5, -0.5, -0.5,
        // +Z face
        -0.5, -0.5, 0.5,
        -0.5, 0.5, 0.5,
        0.5, 0.5, 0.5,
        0.5, -0.5, 0.5,
        // -Z face
        -0.5, -0.5, -0.5,
        0.5, -0.5, -0.5,
        0.5, 0.5, -0.5,
        -0.5, 0.5, -0.5,
        // +X face
        0.5, -0.5, -0.5,
        0.5, -0.5, 0.5,
        0.5, 0.5, 0.5,
        0.5, 0.5, -0.5,
        // -X face
        -0.5, -0.5, -0.5,
        -0.5, 0.5, -0.5,
        -0.5, 0.5, 0.5,
        -0.5, -0.5, 0.5
      ]);

      const normals = new Float32Array([
        // +Y face
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        // -Y face
        0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
        // +Z face
        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        // -Z face
        0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
        // +X face
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
        // -X face
        -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0
      ]);

      const indices = new Uint16Array([
        0, 1, 2, 0, 2, 3,
        4, 5, 6, 4, 6, 7,
        8, 9, 10, 8, 10, 11,
        12, 13, 14, 12, 14, 15,
        16, 17, 18, 16, 18, 19,
        20, 21, 22, 20, 22, 23
      ]);

      return {
        attributes: {
          POSITION: { value: positions, size: 3 },
          NORMAL: { value: normals, size: 3 }
        },
        indices: { value: indices }
      };
    }

    function lngLatToWorld(lonLat) {
      const [lon, lat] = lonLat;
      const lambda = (lon * Math.PI) / 180;
      const phi = (lat * Math.PI) / 180;
      const x = ((lambda + Math.PI) / (2 * Math.PI)) * TILE_SIZE;
      const y =
        ((Math.PI - Math.log(Math.tan(Math.PI / 4 + phi / 2))) / (2 * Math.PI)) * TILE_SIZE;
      return [x, y];
    }

    function horizontalDistanceMeters(a, b) {
      const R = 6371000;
      const lat1 = (a[1] * Math.PI) / 180;
      const lat2 = (b[1] * Math.PI) / 180;
      const dLat = lat2 - lat1;
      const dLon = ((b[0] - a[0]) * Math.PI) / 180;
      const sinLat = Math.sin(dLat / 2);
      const sinLon = Math.sin(dLon / 2);
      const h = sinLat * sinLat + Math.cos(lat1) * Math.cos(lat2) * sinLon * sinLon;
      const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
      return R * c;
    }

    function segsFromLineString(coordsLLA) {
      const segs = [];
      for (let i = 0; i < coordsLLA.length - 1; i++) {
        const a = coordsLLA[i];
        const b = coordsLLA[i + 1];
        const za = a[2] || 0;
        const zb = b[2] || 0;

        const A = lngLatToWorld(a);
        const B = lngLatToWorld(b);
        const dx = B[0] - A[0];
        const dy = B[1] - A[1];
        const dz = zb - za;
        const lenXY = horizontalDistanceMeters(a, b);
        const len3 = Math.hypot(lenXY, dz);
        if (len3 === 0) {
          continue;
        }

        const midLon = (a[0] + b[0]) / 2;
        const midLat = (a[1] + b[1]) / 2;
        const midZ = (za + zb) / 2;
        const yaw = Math.atan2(dx, dy) * RAD2DEG;
        const pitch = Math.atan2(dz, lenXY) * RAD2DEG;

        segs.push({
          position: [midLon, midLat, midZ],
          length: len3,
          yaw,
          pitch
        });
      }
      return segs;
    }

    function scaleLineCoords(coords, multiplier) {
      return coords.map(coord => {
        const lon = coord[0];
        const lat = coord[1];
        const altitude = (typeof coord[2] === 'number' ? coord[2] : 0) * multiplier;
        return [lon, lat, altitude];
      });
    }

    function collectBeamSegments(geojson, multiplier) {
      const segments = [];
      const features = Array.isArray(geojson.features) ? geojson.features : [];
      for (const feature of features) {
        if (!feature || !feature.geometry) {
          continue;
        }
        const { type, coordinates } = feature.geometry;
        if (type === 'LineString') {
          segments.push(...segsFromLineString(scaleLineCoords(coordinates, multiplier)));
        } else if (type === 'MultiLineString') {
          for (const line of coordinates) {
            segments.push(...segsFromLineString(scaleLineCoords(line, multiplier)));
          }
        }
      }
      return segments;
    }

    const unitBoxMesh = makeUnitBoxMesh();

    // Load local GeoJSON (must be in same directory)
    fetch('rjtt_rwy16r_sid_taura_demo.geojson')
      .then(r => r.json())
      .then(data => {
        const pointColor = [0, 120, 255, 220];
        const beamColor = [30, 80, 200];

        const slider = document.getElementById('alt-scale');
        const sliderValue = document.getElementById('alt-scale-value');

        const toMultiplier = value => Math.pow(2, value);

        const formatMultiplier = multiplier => {
          if (multiplier >= 10) {
            return `${multiplier.toFixed(0)}x`;
          }
          if (multiplier >= 1) {
            return `${multiplier.toFixed(1)}x`;
          }
          return `${multiplier.toFixed(2)}x`;
        };

        let altitudeMultiplier = toMultiplier(parseFloat(slider.value));

        const updateSliderDisplay = multiplier => {
          sliderValue.textContent = formatMultiplier(multiplier);
        };

        const buildLayers = multiplier => {
          const beamData = collectBeamSegments(data, multiplier);
          return [
            new deck.SimpleMeshLayer({
              id: 'sid-line',
              data: beamData,
              mesh: unitBoxMesh,
              getPosition: d => d.position,
              getScale: d => [WIDTH_M, HEIGHT_M, d.length],
              getOrientation: d => [d.pitch, d.yaw, 0],
              getColor: beamColor,
              pickable: true,
              parameters: { depthTest: true }
            }),
            new deck.GeoJsonLayer({
              id: 'sid-points',
              data,
              pickable: true,
              pointType: 'circle',
              getPointRadius: 120,
              getFillColor: f => (f.geometry.type === 'Point' ? pointColor : [0, 0, 0, 0]),
              getElevation: f => {
                if (f.geometry.type !== 'Point') {
                  return 0;
                }
                const alt = f.properties && typeof f.properties.altitude_m === 'number'
                  ? f.properties.altitude_m
                  : (Array.isArray(f.geometry.coordinates) && typeof f.geometry.coordinates[2] === 'number'
                    ? f.geometry.coordinates[2]
                    : 0);
                return alt * multiplier;
              },
              elevationScale: 1,
              extruded: true,
              updateTriggers: {
                getElevation: [multiplier]
              },
              onHover: info => {
                const el = map.getCanvasContainer();
                el.style.cursor = info.object ? 'pointer' : '';
              },
              onClick: info => {
                if (info.object) {
                  const p = info.object.properties || {};
                  const name = p.name || p.ident || 'Fix';
                  const altm = p.altitude_m !== undefined ? `${p.altitude_m} m` : '—';
                  const altft = p.altitude_ft !== undefined ? `${p.altitude_ft} ft` : '—';
                  const note = p.alt_restriction_ft || p.note || '';
                  alert(`${name}\nalt(m): ${altm}\nalt(ft): ${altft}\n${note}`);
                }
              }
            })
          ];
        };

        overlay.setProps({ layers: buildLayers(altitudeMultiplier) });
        updateSliderDisplay(altitudeMultiplier);

        slider.addEventListener('input', () => {
          altitudeMultiplier = toMultiplier(parseFloat(slider.value));
          updateSliderDisplay(altitudeMultiplier);
          overlay.setProps({ layers: buildLayers(altitudeMultiplier) });
        });

        // Fit to extent around Tokyo Bay
        map.fitBounds([[139.4, 35.3], [140.1, 35.8]], { padding: 50, duration: 1200 });
      })
      .catch(err => console.error('Failed to load GeoJSON:', err));
  </script>
</body>
</html>
